//! Integration with `make` build tool.
//!
//! Megaton puts the artifacts in the `./target/megaton/<flavor>/<profile>/make` directory:
//! - `build.mk`: The Makefile
//! - `build`: The build output directory

use std::collections::BTreeMap;
use std::io::{BufRead, BufReader};
use std::path::Path;
use std::process::{Command, Stdio};

use serde::{Deserialize, Serialize};

use crate::error::Error;
use crate::{errorln, infoln, MegatonConfig, MegatonHammer};

macro_rules! format_makefile_template {
    ($($args:tt)*) => {
        format!(
r###"
# GENERATED BY MEGATON HAMMER
include $(DEVKITPRO)/libnx/switch_rules

MEGATON_MODULE_NAME := {MEGATON_MODULE_NAME}
MEGATON_MODULE_ENTRY := {MEGATON_MODULE_ENTRY}
MEGATON_MODULE_TITLE_ID := 0x{MEGATON_MODULE_TITLE_ID}
MEGATON_ROOT := {MEGATON_ROOT}

TARGET := $(MEGATON_MODULE_NAME)
VERFILE := verfile

DEFAULT_ARCH_FLAGS := \
    -march=armv8-a+crc+crypto \
    -mtune=cortex-a57 \
    -mtp=soft \
    -fPIC \
    -fvisibility=hidden \

DEFAULT_CFLAGS := \
    -D__SWITCH__ \
    -g \
    -Wall \
    -Werror \
    -fdiagnostics-color=always \
    -ffunction-sections \
    -fdata-sections \
    -fvisibility=hidden \
    -O3 \

DEFAULT_CXXFLAGS := \
    -fno-rtti \
    -fno-exceptions \
    -fno-asynchronous-unwind-tables \
    -fno-unwind-tables \
    -fpermissive \
    -std=gnu++20 \

DEFAULT_ASFLAGS := -g
DEFAULT_LDFLAGS := \
    -g \
    -Wl,-Map,$(TARGET).map \
    -nostartfiles \
    -Wl,--shared \
    -Wl,--export-dynamic \
    -Wl,-z,nodynamic-undefined-weak \
    -Wl,--gc-sections \
    -Wl,--build-id=sha1 \
    -Wl,--nx-module-name \
    -Wl,-init=$(MEGATON_MODULE_ENTRY) \
    -Wl,--version-script=$(VERFILE) \
    -Wl,--exclude-libs=ALL \

DEFAULT_LIBS :=

{EXTRA_SECTION}

SOURCES          := $(SOURCES) {SOURCES}
ALL_SOURCE_DIRS  := $(ALL_SOURCE_DIRS) $(foreach dir,$(SOURCES),$(shell find $(dir) -type d))
VPATH            := $(VPATH) $(ALL_SOURCE_DIRS)

INCLUDES         := $(INCLUDES) {INCLUDES}
LIBDIRS          := $(LIBDIRS) $(PORTLIBS) $(LIBNX)
INCLUDE_FLAGS    := $(foreach dir,$(INCLUDES),-I$(dir)) $(foreach dir,$(LIBDIRS),-I$(dir)/include)

DEFINES          := $(DEFINES) {DEFINES}

ARCH_FLAGS       := $(ARCH_FLAGS) {ARCH_FLAGS}
CFLAGS           := $(CFLAGS) $(ARCH_FLAGS) $(DEFINES) $(INCLUDE_FLAGS) {CFLAGS}
CXXFLAGS         := $(CFLAGS) $(CXXFLAGS) {CXXFLAGS}
ASFLAGS          := $(ASFLAGS) $(ARCH_FLAGS) {ASFLAGS}

LD_SCRIPTS       := {LD_SCRIPTS}
LD_SCRIPTS_FLAGS := $(foreach ld,$(LD_SCRIPTS),-Wl,-T,$(ld))
LD               := $(CXX)
LDFLAGS          := $(LDFLAGS) $(ARCH_FLAGS) $(LD_SCRIPTS_FLAGS) {LDFLAGS}
LIBS             := $(LIBS) {LIBS}
LIBPATHS         := $(LIBPATHS) $(foreach dir,$(LIBDIRS),-L$(dir)/lib) 

DEPSDIR          ?= .
CFILES           := $(foreach dir,$(ALL_SOURCE_DIRS),$(notdir $(wildcard $(dir)/*.c)))
CPPFILES         := $(foreach dir,$(ALL_SOURCE_DIRS),$(notdir $(wildcard $(dir)/*.cpp)))
SFILES           := $(foreach dir,$(ALL_SOURCE_DIRS),$(notdir $(wildcard $(dir)/*.s)))
OFILES           := $(CPPFILES:.cpp=.o) $(CFILES:.c=.o) $(SFILES:.s=.o)
DFILES           := $(OFILES:.o=.d)

$(TARGET).nso: $(TARGET).elf
$(TARGET).elf: $(OFILES) $(LD_SCRIPTS) $(VERFILE)
$(VERFILE):
	@echo $(VERFILE)
	@echo "{{" > $(VERFILE)
	@echo "    global:" >> $(VERFILE)
	@echo "        $(MEGATON_MODULE_ENTRY);" >> $(VERFILE)
	@echo "    local: *;" >> $(VERFILE)
	@echo "}};" >> $(VERFILE)

-include $(DFILES)

"###,
        $($args)*
        )
    };
}

macro_rules! default_or_empty {
    ($make:ident, $default:expr) => {
        if $make.no_default_flags.unwrap_or_default() {
            ""
        } else {
            $default
        }
    };
}

impl MegatonConfig {
    /// Create the Makefile content from the config
    pub fn create_makefile(&self, cli: &MegatonHammer) -> Result<String, Error> {
        let mut root = Path::new(&cli.dir)
            .canonicalize()
            .map_err(|e| Error::AccessDirectory(cli.dir.clone(), e))?
            .display()
            .to_string();
        if !root.ends_with('/') {
            root.push('/');
        }

        let make = self.make.get_profile(&cli.options.profile);

        let entry = make.entry.as_ref().ok_or(Error::NoEntryPoint)?;

        let extra_section = make
            .extra
            .iter()
            .map(|s| format!("{} := {}", s.key, s.val))
            .collect::<Vec<_>>()
            .join("\n");

        let sources = make
            .sources
            .iter()
            .map(|s| format!("$(MEGATON_ROOT){s}"))
            .collect::<Vec<_>>()
            .join(" ");
        let includes = make
            .includes
            .iter()
            .map(|s| format!("$(MEGATON_ROOT){s}"))
            .collect::<Vec<_>>()
            .join(" ");
        let ld_scripts = make
            .ld_scripts
            .iter()
            .map(|s| format!("$(MEGATON_ROOT){s}"))
            .collect::<Vec<_>>()
            .join(" ");
        let defines = make
            .defines
            .iter()
            .map(|s| format!("-D{s}"))
            .collect::<Vec<_>>()
            .join(" ");

        let makefile = format_makefile_template!(
            MEGATON_MODULE_NAME = self.module.name,
            MEGATON_MODULE_ENTRY = entry,
            MEGATON_MODULE_TITLE_ID = self.module.title_id_hex(),
            MEGATON_ROOT = root,
            EXTRA_SECTION = extra_section,
            SOURCES = sources,
            INCLUDES = includes,
            DEFINES = defines,
            ARCH_FLAGS = default_or_empty!(make, "$(DEFAULT_ARCH_FLAGS)"),
            CFLAGS = default_or_empty!(make, "$(DEFAULT_CFLAGS)"),
            CXXFLAGS = default_or_empty!(make, "$(DEFAULT_CXXFLAGS)"),
            ASFLAGS = default_or_empty!(make, "$(DEFAULT_ASFLAGS)"),
            LD_SCRIPTS = ld_scripts,
            LDFLAGS = default_or_empty!(make, "$(DEFAULT_LDFLAGS)"),
            LIBS = default_or_empty!(make, "$(DEFAULT_LIBS)"),
        );

        Ok(makefile)
    }
}

/// Compiler command for IDE integration. See
/// <https://clang.llvm.org/docs/JSONCompilationDatabase.html>
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct CompilerCommand {
    /// The working directory of the compilation. All paths specified in the command or file fields must be either absolute or relative to this directory.
    pub directory: String,
    /// The main translation unit source processed by this compilation step. This is used by tools as the key into the compilation database. There can be multiple command objects for the same file, for example if the same source file is compiled with different configurations.
    pub file: String,
    /// The compile command as a single shell-escaped string. Arguments may be shell quoted and escaped following platform conventions, with ‘"’ and ‘\’ being the only special characters. Shell expansion is not supported.
    pub command: String,
    /// The name of the output created by this compilation step.
    pub output: String,
}

impl CompilerCommand {
    pub fn from_command(dkp_bin_path: &str, build_directory: &str, command: &str) -> Self {
        // hopefully there are no spaces in the source paths...:)
        let mut iter = command.split_whitespace();
        let mut file = String::new();
        let mut output = String::new();
        while let Some(arg) = iter.next() {
            match arg {
                "-c" => {
                    if let Some(arg) = iter.next() {
                        file = arg.to_string();
                    }
                }
                "-o" => {
                    if let Some(arg) = iter.next() {
                        output = arg.to_string();
                    }
                }
                _ => {}
            }
        }
        Self {
            directory: build_directory.to_string(),
            file,
            command: format!("{dkp_bin_path}{command}"),
            output,
        }
    }
}

pub fn invoke_make<SRoot, SBuild>(
    root_dir: SRoot,
    build_dir: SBuild,
    makefile_path: &str,
    target: &str,
    dkp_bin_path: &str,
    save_compiler_commands: bool,
) -> Result<(), Error>
where
    SRoot: AsRef<Path>,
    SBuild: AsRef<Path>,
{
    let root_dir = root_dir.as_ref();
    let build_dir = build_dir.as_ref();
    let j_flag = format!("-j{}", num_cpus::get());
    infoln!("Making", "{}", target);
    let build_dir_str = build_dir.display().to_string();
    let args = vec![
        "--no-print-directory",
        "V=1",
        &j_flag,
        "-C",
        &build_dir_str,
        "-f",
        makefile_path,
        target,
    ];
    let command = format!("make {:?}", args);
    let mut child = Command::new("make")
        .args(args)
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()
        .map_err(|e| Error::Subprocess(command.clone(), "cannot spawn child".to_string(), e))?;

    // load compiler commands
    let mut compiler_commands = BTreeMap::new();
    let cc_json_path = build_dir.join("compile_commands.json");
    if save_compiler_commands && cc_json_path.exists() {
        let cc_json = std::fs::read_to_string(&cc_json_path)
            .map_err(|e| Error::AccessFile(cc_json_path.display().to_string(), e))?;
        if let Ok(cc_vec) = serde_json::from_str::<Vec<CompilerCommand>>(&cc_json) {
            for command in cc_vec {
                compiler_commands.insert(command.file.clone(), command);
            }
        }
    }

    let build_dir_abs = build_dir.canonicalize().map_err(|e| {
        Error::AccessDirectory(build_dir.display().to_string(), e)
    })?;
    let root_dir_abs = root_dir.canonicalize().map_err(|e| {
        Error::AccessDirectory(root_dir.display().to_string(), e)
    })?;
    let cc_build_path = build_dir_abs.display().to_string();

    if let Some(stdout) = child.stdout.take() {
        let stdout = BufReader::new(stdout);
        for line in stdout.lines() {
            if let Ok(line) = line {
                // hide some outputs
                if line.starts_with("built ...") {
                    continue;
                }
                if line.ends_with("up to date.") {
                    continue;
                }
                if line.starts_with("aarch64-none-elf-") {
                    // compiler command
                    let compiler_command =
                    CompilerCommand::from_command(dkp_bin_path, &cc_build_path, &line);
                    if let Some(file_path) = pathdiff::diff_paths(Path::new(&compiler_command.file), &root_dir_abs) {
                        infoln!("Compiling", "{}", file_path.display());
                    }
                    compiler_commands.insert(compiler_command.file.clone(), compiler_command);
                    continue;
                }
                if let Some(line) = line.strip_prefix("linking ") {
                    infoln!("Linking", "{}", line);
                }
                // else {
                //     infoln!("Make", "{}", line);
                // }
            }
        }
    }

    if let Some(stderr) = child.stderr.take() {
        let stderr = BufReader::new(stderr);
        for line in stderr.lines() {
            if let Ok(line) = line {
                // hide some outputs
                if line.starts_with("make: ***") {
                    continue;
                }
                if line == "compilation terminated." {
                    continue;
                }
                errorln!("Error", "{}", line);
            }
        }
    }

    let status = child
        .wait()
        .map_err(|e| Error::Subprocess(command.clone(), "cannot wait for child".to_string(), e))?;
    if !status.success() {
        return Err(Error::MakeError);
    }

    infoln!("Finished", "{}", target);

    if save_compiler_commands {
        let vec = compiler_commands.into_values().collect::<Vec<_>>();

        match serde_json::to_string_pretty(&vec) {
            Err(e) => {
                errorln!("Error", "Failed to serialize compiler commands: {}", e);
            }
            Ok(json) => {
                std::fs::write(&cc_json_path, json).map_err(|e| {
                    Error::AccessFile(cc_json_path.display().to_string(), e)
                })?;
                infoln!("Saved", "compile_commands.json")
            }
        }
    }


    Ok(())
}
