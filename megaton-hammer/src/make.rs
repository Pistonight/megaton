//! Integration with `make` build tool.
//!
//! Megaton puts the artifacts in the `./target/megaton/<flavor>/<profile>/make` directory:
//! - `build.mk`: The Makefile
//! - `build`: The build output directory

use std::io::{BufReader, BufRead};
use std::path::Path;
use std::process::{Command, Stdio};

use crate::{MegatonConfig, MegatonHammer, infoln, errorln};
use crate::error::Error;

macro_rules! format_makefile_template {
    ($($args:tt)*) => {
        format!(
r###"
# GENERATED BY MEGATON HAMMER
include $(DEVKITPRO)/libnx/switch_rules

MEGATON_MODULE_NAME := {MEGATON_MODULE_NAME}
MEGATON_MODULE_ENTRY := {MEGATON_MODULE_ENTRY}
MEGATON_MODULE_TITLE_ID := 0x{MEGATON_MODULE_TITLE_ID}
MEGATON_ROOT := {MEGATON_ROOT}

TARGET := $(MEGATON_MODULE_NAME)

DEFAULT_ARCH_FLAGS := \
    -march=armv8-a+crc+crypto \
    -mtune=cortex-a57 \
    -mtp=soft \
    -fPIC \
    -fvisibility=hidden \

DEFAULT_CFLAGS := \
    -g \
    -Wall \
    -Werror \
    -fdiagnostics-color=always \
    -ffunction-sections \
    -fdata-sections \
    -O3 \

DEFAULT_CXXFLAGS := \
    -fno-rtti \
    -fomit-frame-pointer \
    -fno-exceptions \
    -fno-asynchronous-unwind-tables \
    -fno-unwind-tables \
    -enable-libstdcxx-allocator=new \
    -fpermissive \
    -std=c++20 \

DEFAULT_ASFLAGS := -g
DEFAULT_LDFLAGS := \
    -g \
    -Wl,-Map,$(TARGET).map \
    -nodefaultlibs \
    -nostartfiles \
    -Wl,--shared \
    -Wl,--export-dynamic \
    -Wl,-z,nodynamic-undefined-weak \
    -Wl,--gc-sections \
    -Wl,--build-id=sha1 \
    -Wl,--nx-module-name \
    -Wl,-init=$(MEGATON_MODULE_ENTRY) \
    -Wl,--exclude-libs=ALL \

DEFAULT_LIBS := -lgcc -lstdc++ -u malloc

{EXTRA_SECTION}

SOURCES          := $(SOURCES) {SOURCES}
ALL_SOURCE_DIRS  := $(ALL_SOURCE_DIRS) $(foreach dir,$(SOURCES),$(shell find $(dir) -type d))
VPATH            := $(VPATH) $(ALL_SOURCE_DIRS)

INCLUDES         := $(INCLUDES) {INCLUDES}
LIBDIRS          := $(LIBDIRS) $(PORTLIBS) $(LIBNX)
INCLUDE_FLAGS    := $(foreach dir,$(INCLUDES),-I$(dir)) $(foreach dir,$(LIBDIRS),-I$(dir)/include)

DEFINES          := $(DEFINES) {DEFINES}

ARCH_FLAGS       := $(ARCH_FLAGS) {ARCH_FLAGS}
CFLAGS           := $(CFLAGS) $(ARCH_FLAGS) $(DEFINES) $(INCLUDE_FLAGS) {CFLAGS}
CXXFLAGS         := $(CFLAGS) $(CXXFLAGS) {CXXFLAGS}
ASFLAGS          := $(ASFLAGS) $(ARCH_FLAGS) {ASFLAGS}

LD_SCRIPTS       := {LD_SCRIPTS}
LD_SCRIPTS_FLAGS := $(foreach ld,$(LD_SCRIPTS),-Wl,-T,$(CURDIR)/$(ld))
LD               := $(CXX)
LDFLAGS          := $(LDFLAGS) $(ARCH_FLAGS) $(LD_SCRIPTS_FLAGS) {LDFLAGS}
LIBS             := $(LIBS) {LIBS}
LIBPATHS         := $(LIBPATHS) $(foreach dir,$(LIBDIRS),-L$(dir)/lib) 

DEPSDIR          ?= .
CFILES           := $(foreach dir,$(ALL_SOURCE_DIRS),$(notdir $(wildcard $(dir)/*.c)))
CPPFILES         := $(foreach dir,$(ALL_SOURCE_DIRS),$(notdir $(wildcard $(dir)/*.cpp)))
SFILES           := $(foreach dir,$(ALL_SOURCE_DIRS),$(notdir $(wildcard $(dir)/*.s)))
OFILES           := $(CPPFILES:.cpp=.o) $(CFILES:.c=.o) $(SFILES:.s=.o)
DFILES           := $(OFILES:.o=.d)

$(TARGET).nso: $(TARGET).elf
$(TARGET).elf: $(OFILES) $(LD_SCRIPTS)

-include $(DFILES)

"###,
        $($args)*
        )
    };
}

macro_rules! default_or_empty {
    ($make:ident, $default:expr) => {
        if $make.no_default_flags.unwrap_or_default() {
            ""
        } else {
            $default
        }
    };
}

impl MegatonConfig {
    /// Create the Makefile content from the config
    pub fn create_makefile(&self, cli: &MegatonHammer) -> Result<String, Error> {
        let mut root = Path::new(&cli.dir).canonicalize().map_err(|e| Error::AccessDirectory(cli.dir.clone(), e))?.display().to_string();
        if !root.ends_with('/') {
            root.push('/');
        }

        let make = self.make.get_profile(&cli.options.profile);

        let entry = make.entry.as_ref().ok_or(Error::NoEntryPoint)?;

        let extra_section = make.extra.iter().map(|s| format!("{} := {}", s.key, s.val)).collect::<Vec<_>>().join("\n");

        let sources = make.sources.iter().map(|s| format!("$(MEGATON_ROOT){s}")).collect::<Vec<_>>().join(" ");
        let includes = make.includes.iter().map(|s| format!("$(MEGATON_ROOT){s}")).collect::<Vec<_>>().join(" ");
        let ld_scripts = make.ld_scripts.iter().map(|s| format!("$(MEGATON_ROOT){s}")).collect::<Vec<_>>().join(" ");
        let defines = make.defines.iter().map(|s| format!("-D{s}")).collect::<Vec<_>>().join(" ");

        let makefile = format_makefile_template!(
            MEGATON_MODULE_NAME = self.module.name,
            MEGATON_MODULE_ENTRY = entry,
            MEGATON_MODULE_TITLE_ID = self.module.title_id_hex(),
            MEGATON_ROOT = root,
            EXTRA_SECTION = extra_section,
            SOURCES = sources,
            INCLUDES = includes,
            DEFINES = defines,
            ARCH_FLAGS = default_or_empty!(make, "$(DEFAULT_ARCH_FLAGS)"),
            CFLAGS = default_or_empty!(make, "$(DEFAULT_CFLAGS)"),
            CXXFLAGS = default_or_empty!(make, "$(DEFAULT_CXXFLAGS)"),
            ASFLAGS = default_or_empty!(make, "$(DEFAULT_ASFLAGS)"),
            LD_SCRIPTS = ld_scripts,
            LDFLAGS = default_or_empty!(make, "$(DEFAULT_LDFLAGS)"),
            LIBS = default_or_empty!(make, "$(DEFAULT_LIBS)"),
        );

        Ok(makefile)
    }
}

pub fn invoke_make(build_directory: &str, makefile_path: &str, target: &str) -> Result<(), Error> {
    let j_flag = format!("-j{}", num_cpus::get());
    infoln!("Making", "`{}`", target);
    let args = vec![
        "--no-print-directory",
        &j_flag,
        "-C",
        build_directory,
        "-f",
        makefile_path,
        target
    ];
    let command = format!("make {:?}", args);
    let mut child = Command::new("make")
        .args([
            "--no-print-directory",
            &j_flag,
            "-C",
            build_directory,
            "-f",
            makefile_path,
            target
        ])
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()
        .map_err(|e| Error::Subprocess(command.clone(), "cannot spawn child".to_string(), e))?;

    if let Some(stdout) = child.stdout.take() {
        let stdout = BufReader::new(stdout);
        for line in stdout.lines() {
            if let Ok(line) = line {
                infoln!("Compiling", "{}", line);
            }
        }
    }

    if let Some(stderr) = child.stderr.take() {
        let stderr = BufReader::new(stderr);
        for line in stderr.lines() {
            if let Ok(line) = line {
                // hide some outputs
                if line.starts_with("make: ***") {
                    continue;
                }
                if line == "compilation terminated." {
                    continue;
                }
                errorln!("Error", "{}", line);
            }
        }
    }

    let status = child.wait().map_err(|e| Error::Subprocess(command.clone(), "cannot wait for child".to_string(), e))?;
    if !status.success() {
        return Err(Error::MakeError);
    }

    infoln!("Finished", "`{}`", target);

    Ok(())

}
